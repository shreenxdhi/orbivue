{"ast":null,"code":"import axios from 'axios';\n// API configuration using environment variables\nconst API_KEY = process.env.REACT_APP_OPENWEATHERMAP_API_KEY || 'f0fd7a09787e01aa6a78edace652c5d7';\nconst USE_CORS_PROXY = process.env.REACT_APP_USE_CORS_PROXY === 'true';\nconst CORS_PROXY_URL = process.env.REACT_APP_CORS_PROXY_URL || 'https://cors-anywhere.herokuapp.com/';\nconst IS_DEV = process.env.NODE_ENV === 'development';\n\n// API URLs for production vs development\nconst BASE_URL = IS_DEV ? '/api/weather' : 'https://api.openweathermap.org/data/2.5';\nconst GEO_URL = IS_DEV ? '/api/geo' : 'https://api.openweathermap.org/geo/1.0';\n\n// Function to build API URL with optional CORS proxy (for non-dev environments)\nconst buildApiUrl = baseUrl => {\n  if (IS_DEV) return baseUrl; // Use local proxy in development\n  return USE_CORS_PROXY ? `${CORS_PROXY_URL}${baseUrl}` : baseUrl;\n};\n\n// Default weather data for fallback\nconst DEFAULT_WEATHER = {\n  location: 'New York',\n  temperature: 22.5,\n  feelsLike: 23.2,\n  humidity: 65,\n  pressure: 1012,\n  windSpeed: 5.7,\n  windDirection: 'NE',\n  description: 'partly cloudy',\n  icon: '02d',\n  sunrise: new Date(new Date().setHours(5, 45, 0, 0)),\n  sunset: new Date(new Date().setHours(20, 15, 0, 0))\n};\n\n// Convert wind direction in degrees to cardinal direction\nconst getWindDirection = degrees => {\n  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];\n  return directions[Math.round(degrees / 45) % 8];\n};\n\n// Generate mock forecast data for fallback\nconst generateMockForecast = () => {\n  const forecast = [];\n  const weatherIcons = ['01d', '02d', '03d', '04d', '10d'];\n  const weatherDescriptions = ['clear sky', 'few clouds', 'scattered clouds', 'broken clouds', 'rain'];\n  const today = new Date();\n  for (let i = 1; i <= 5; i++) {\n    const date = new Date(today);\n    date.setDate(today.getDate() + i);\n    const randomIconIndex = Math.floor(Math.random() * weatherIcons.length);\n    forecast.push({\n      date,\n      minTemp: 15 + Math.random() * 3,\n      maxTemp: 20 + Math.random() * 5,\n      description: weatherDescriptions[randomIconIndex],\n      icon: weatherIcons[randomIconIndex],\n      precipitation: Math.round(Math.random() * 100),\n      humidity: 40 + Math.round(Math.random() * 50),\n      windSpeed: 2 + Math.round(Math.random() * 10 * 10) / 10\n    });\n  }\n  return forecast;\n};\n\n// Get weather data for location\nexport const fetchWeatherData = async (lat, lon, searchQuery) => {\n  try {\n    let latitude = lat;\n    let longitude = lon;\n    let locationName = '';\n\n    // If search query is provided, geocode it to get coordinates\n    if (searchQuery) {\n      try {\n        const geoResponse = await axios.get(buildApiUrl(`${GEO_URL}/direct`), {\n          params: {\n            q: searchQuery,\n            limit: 1,\n            appid: API_KEY\n          },\n          headers: {\n            'X-Requested-With': 'XMLHttpRequest'\n          }\n        });\n        if (geoResponse.data.length === 0) {\n          throw new Error(`Location \"${searchQuery}\" not found`);\n        }\n        const location = geoResponse.data[0];\n        latitude = location.lat;\n        longitude = location.lon;\n        locationName = location.name + (location.state ? `, ${location.state}` : '') + (location.country ? `, ${location.country}` : '');\n      } catch (geoError) {\n        console.error('Geocoding error:', geoError);\n        throw new Error(`Could not find location: ${searchQuery}`);\n      }\n    }\n\n    // Get current weather data\n    const weatherResponse = await axios.get(buildApiUrl(`${BASE_URL}/weather`), {\n      params: {\n        lat: latitude,\n        lon: longitude,\n        units: 'metric',\n        appid: API_KEY\n      },\n      headers: {\n        'X-Requested-With': 'XMLHttpRequest'\n      }\n    });\n    const data = weatherResponse.data;\n    return {\n      location: locationName || data.name,\n      temperature: data.main.temp,\n      feelsLike: data.main.feels_like,\n      humidity: data.main.humidity,\n      pressure: data.main.pressure,\n      windSpeed: data.wind.speed,\n      windDirection: getWindDirection(data.wind.deg),\n      description: data.weather[0].description,\n      icon: data.weather[0].icon,\n      sunrise: new Date(data.sys.sunrise * 1000),\n      sunset: new Date(data.sys.sunset * 1000)\n    };\n  } catch (error) {\n    console.error('Error fetching weather data:', error);\n\n    // In development mode, return mocked data if API fails\n    if (process.env.NODE_ENV === 'development') {\n      console.log('Using fallback weather data in development mode');\n      return {\n        ...DEFAULT_WEATHER,\n        location: searchQuery || DEFAULT_WEATHER.location\n      };\n    }\n    throw new Error(error instanceof Error ? error.message : 'Error fetching weather data');\n  }\n};\n\n// Get forecast for location\nexport const fetchForecast = async (lat, lon, searchQuery) => {\n  try {\n    let latitude = lat;\n    let longitude = lon;\n\n    // If search query is provided, geocode it to get coordinates\n    if (searchQuery) {\n      try {\n        const geoResponse = await axios.get(buildApiUrl(`${GEO_URL}/direct`), {\n          params: {\n            q: searchQuery,\n            limit: 1,\n            appid: API_KEY\n          },\n          headers: {\n            'X-Requested-With': 'XMLHttpRequest'\n          }\n        });\n        if (geoResponse.data.length === 0) {\n          throw new Error(`Location \"${searchQuery}\" not found`);\n        }\n        const location = geoResponse.data[0];\n        latitude = location.lat;\n        longitude = location.lon;\n      } catch (geoError) {\n        console.error('Geocoding error:', geoError);\n        if (process.env.NODE_ENV === 'development') {\n          return generateMockForecast();\n        }\n        throw new Error(`Could not find location: ${searchQuery}`);\n      }\n    }\n\n    // Get 5-day forecast data\n    const forecastResponse = await axios.get(buildApiUrl(`${BASE_URL}/forecast`), {\n      params: {\n        lat: latitude,\n        lon: longitude,\n        units: 'metric',\n        appid: API_KEY\n      },\n      headers: {\n        'X-Requested-With': 'XMLHttpRequest'\n      }\n    });\n    const forecast = [];\n    const dailyData = {};\n\n    // Process forecast data (comes in 3-hour increments)\n    forecastResponse.data.list.forEach(item => {\n      const date = new Date(item.dt * 1000);\n      const day = date.toISOString().split('T')[0];\n\n      // Initialize daily data if it doesn't exist\n      if (!dailyData[day]) {\n        dailyData[day] = {\n          date: new Date(date),\n          minTemp: item.main.temp_min,\n          maxTemp: item.main.temp_max,\n          descriptions: {},\n          icons: {},\n          humidity: [],\n          windSpeed: [],\n          precipitation: item.pop * 100 || 0\n        };\n      } else {\n        // Update min/max temperatures\n        dailyData[day].minTemp = Math.min(dailyData[day].minTemp, item.main.temp_min);\n        dailyData[day].maxTemp = Math.max(dailyData[day].maxTemp, item.main.temp_max);\n        dailyData[day].precipitation = Math.max(dailyData[day].precipitation, item.pop * 100 || 0);\n      }\n\n      // Track weather descriptions and icons to find most common\n      const desc = item.weather[0].description;\n      const icon = item.weather[0].icon.replace('n', 'd'); // normalize night/day icons\n\n      dailyData[day].descriptions[desc] = (dailyData[day].descriptions[desc] || 0) + 1;\n      dailyData[day].icons[icon] = (dailyData[day].icons[icon] || 0) + 1;\n\n      // Collect humidity and wind speed values\n      dailyData[day].humidity.push(item.main.humidity);\n      dailyData[day].windSpeed.push(item.wind.speed);\n    });\n\n    // Convert daily data to forecast format\n    Object.keys(dailyData).forEach(day => {\n      const data = dailyData[day];\n\n      // Find most common description and icon\n      let maxDescCount = 0;\n      let description = '';\n      Object.entries(data.descriptions).forEach(([desc, count]) => {\n        if (count > maxDescCount) {\n          maxDescCount = count;\n          description = desc;\n        }\n      });\n      let maxIconCount = 0;\n      let icon = '';\n      Object.entries(data.icons).forEach(([ic, count]) => {\n        if (count > maxIconCount) {\n          maxIconCount = count;\n          icon = ic;\n        }\n      });\n\n      // Calculate averages\n      const avgHumidity = Math.round(data.humidity.reduce((a, b) => a + b, 0) / data.humidity.length);\n      const avgWindSpeed = Math.round(data.windSpeed.reduce((a, b) => a + b, 0) / data.windSpeed.length * 10) / 10;\n      forecast.push({\n        date: data.date,\n        minTemp: data.minTemp,\n        maxTemp: data.maxTemp,\n        description,\n        icon,\n        precipitation: Math.round(data.precipitation),\n        humidity: avgHumidity,\n        windSpeed: avgWindSpeed\n      });\n    });\n\n    // Sort by date\n    forecast.sort((a, b) => a.date.getTime() - b.date.getTime());\n\n    // Limit to 5 days\n    return forecast.slice(0, 5);\n  } catch (error) {\n    console.error('Error fetching forecast data:', error);\n\n    // In development mode, return mocked data if API fails\n    if (process.env.NODE_ENV === 'development') {\n      console.log('Using fallback forecast data in development mode');\n      return generateMockForecast();\n    }\n    throw new Error(error instanceof Error ? error.message : 'Error fetching forecast data');\n  }\n};\n\n// Search for city autocomplete suggestions\nexport const searchCities = async query => {\n  if (!query || query.length < 2) return [];\n  try {\n    const response = await axios.get(buildApiUrl(`${GEO_URL}/direct`), {\n      params: {\n        q: query,\n        limit: 5,\n        appid: API_KEY\n      },\n      headers: {\n        'X-Requested-With': 'XMLHttpRequest'\n      }\n    });\n    return response.data.map(city => ({\n      name: city.name,\n      state: city.state,\n      country: city.country,\n      lat: city.lat,\n      lon: city.lon,\n      displayName: `${city.name}${city.state ? `, ${city.state}` : ''}${city.country ? `, ${city.country}` : ''}`\n    }));\n  } catch (error) {\n    console.error('Error searching cities:', error);\n    return [];\n  }\n};","map":{"version":3,"names":["axios","API_KEY","process","env","REACT_APP_OPENWEATHERMAP_API_KEY","USE_CORS_PROXY","REACT_APP_USE_CORS_PROXY","CORS_PROXY_URL","REACT_APP_CORS_PROXY_URL","IS_DEV","NODE_ENV","BASE_URL","GEO_URL","buildApiUrl","baseUrl","DEFAULT_WEATHER","location","temperature","feelsLike","humidity","pressure","windSpeed","windDirection","description","icon","sunrise","Date","setHours","sunset","getWindDirection","degrees","directions","Math","round","generateMockForecast","forecast","weatherIcons","weatherDescriptions","today","i","date","setDate","getDate","randomIconIndex","floor","random","length","push","minTemp","maxTemp","precipitation","fetchWeatherData","lat","lon","searchQuery","latitude","longitude","locationName","geoResponse","get","params","q","limit","appid","headers","data","Error","name","state","country","geoError","console","error","weatherResponse","units","main","temp","feels_like","wind","speed","deg","weather","sys","log","message","fetchForecast","forecastResponse","dailyData","list","forEach","item","dt","day","toISOString","split","temp_min","temp_max","descriptions","icons","pop","min","max","desc","replace","Object","keys","maxDescCount","entries","count","maxIconCount","ic","avgHumidity","reduce","a","b","avgWindSpeed","sort","getTime","slice","searchCities","query","response","map","city","displayName"],"sources":["/Users/shreenidhivasishta/sat/orbivue/src/services/weatherService.ts"],"sourcesContent":["import axios from 'axios';\n\ninterface WeatherData {\n  location: string;\n  temperature: number;\n  feelsLike: number;\n  humidity: number;\n  pressure: number;\n  windSpeed: number;\n  windDirection: string;\n  description: string;\n  icon: string;\n  sunrise: Date;\n  sunset: Date;\n}\n\ninterface ForecastDay {\n  date: Date;\n  minTemp: number;\n  maxTemp: number;\n  description: string;\n  icon: string;\n  precipitation: number;\n  humidity: number;\n  windSpeed: number;\n}\n\n// API configuration using environment variables\nconst API_KEY = process.env.REACT_APP_OPENWEATHERMAP_API_KEY || 'f0fd7a09787e01aa6a78edace652c5d7';\nconst USE_CORS_PROXY = process.env.REACT_APP_USE_CORS_PROXY === 'true';\nconst CORS_PROXY_URL = process.env.REACT_APP_CORS_PROXY_URL || 'https://cors-anywhere.herokuapp.com/';\nconst IS_DEV = process.env.NODE_ENV === 'development';\n\n// API URLs for production vs development\nconst BASE_URL = IS_DEV ? '/api/weather' : 'https://api.openweathermap.org/data/2.5';\nconst GEO_URL = IS_DEV ? '/api/geo' : 'https://api.openweathermap.org/geo/1.0';\n\n// Function to build API URL with optional CORS proxy (for non-dev environments)\nconst buildApiUrl = (baseUrl: string): string => {\n  if (IS_DEV) return baseUrl; // Use local proxy in development\n  return USE_CORS_PROXY ? `${CORS_PROXY_URL}${baseUrl}` : baseUrl;\n};\n\n// Default weather data for fallback\nconst DEFAULT_WEATHER: WeatherData = {\n  location: 'New York',\n  temperature: 22.5,\n  feelsLike: 23.2,\n  humidity: 65,\n  pressure: 1012,\n  windSpeed: 5.7,\n  windDirection: 'NE',\n  description: 'partly cloudy',\n  icon: '02d',\n  sunrise: new Date(new Date().setHours(5, 45, 0, 0)),\n  sunset: new Date(new Date().setHours(20, 15, 0, 0)),\n};\n\n// Convert wind direction in degrees to cardinal direction\nconst getWindDirection = (degrees: number): string => {\n  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];\n  return directions[Math.round(degrees / 45) % 8];\n};\n\n// Generate mock forecast data for fallback\nconst generateMockForecast = (): ForecastDay[] => {\n  const forecast: ForecastDay[] = [];\n  const weatherIcons = ['01d', '02d', '03d', '04d', '10d'];\n  const weatherDescriptions = [\n    'clear sky', 'few clouds', 'scattered clouds', 'broken clouds', 'rain'\n  ];\n  \n  const today = new Date();\n  \n  for (let i = 1; i <= 5; i++) {\n    const date = new Date(today);\n    date.setDate(today.getDate() + i);\n    \n    const randomIconIndex = Math.floor(Math.random() * weatherIcons.length);\n    \n    forecast.push({\n      date,\n      minTemp: 15 + Math.random() * 3,\n      maxTemp: 20 + Math.random() * 5,\n      description: weatherDescriptions[randomIconIndex],\n      icon: weatherIcons[randomIconIndex],\n      precipitation: Math.round(Math.random() * 100),\n      humidity: 40 + Math.round(Math.random() * 50),\n      windSpeed: 2 + Math.round(Math.random() * 10 * 10) / 10,\n    });\n  }\n  \n  return forecast;\n};\n\n// Get weather data for location\nexport const fetchWeatherData = async (\n  lat: number, \n  lon: number, \n  searchQuery?: string\n): Promise<WeatherData> => {\n  try {\n    let latitude = lat;\n    let longitude = lon;\n    let locationName = '';\n\n    // If search query is provided, geocode it to get coordinates\n    if (searchQuery) {\n      try {\n        const geoResponse = await axios.get(buildApiUrl(`${GEO_URL}/direct`), {\n          params: {\n            q: searchQuery,\n            limit: 1,\n            appid: API_KEY\n          },\n          headers: {\n            'X-Requested-With': 'XMLHttpRequest'\n          }\n        });\n\n        if (geoResponse.data.length === 0) {\n          throw new Error(`Location \"${searchQuery}\" not found`);\n        }\n\n        const location = geoResponse.data[0];\n        latitude = location.lat;\n        longitude = location.lon;\n        locationName = location.name + (location.state ? `, ${location.state}` : '') + (location.country ? `, ${location.country}` : '');\n      } catch (geoError) {\n        console.error('Geocoding error:', geoError);\n        throw new Error(`Could not find location: ${searchQuery}`);\n      }\n    }\n\n    // Get current weather data\n    const weatherResponse = await axios.get(buildApiUrl(`${BASE_URL}/weather`), {\n      params: {\n        lat: latitude,\n        lon: longitude,\n        units: 'metric',\n        appid: API_KEY\n      },\n      headers: {\n        'X-Requested-With': 'XMLHttpRequest'\n      }\n    });\n\n    const data = weatherResponse.data;\n    \n    return {\n      location: locationName || data.name,\n      temperature: data.main.temp,\n      feelsLike: data.main.feels_like,\n      humidity: data.main.humidity,\n      pressure: data.main.pressure,\n      windSpeed: data.wind.speed,\n      windDirection: getWindDirection(data.wind.deg),\n      description: data.weather[0].description,\n      icon: data.weather[0].icon,\n      sunrise: new Date(data.sys.sunrise * 1000),\n      sunset: new Date(data.sys.sunset * 1000),\n    };\n  } catch (error) {\n    console.error('Error fetching weather data:', error);\n    \n    // In development mode, return mocked data if API fails\n    if (process.env.NODE_ENV === 'development') {\n      console.log('Using fallback weather data in development mode');\n      return {\n        ...DEFAULT_WEATHER,\n        location: searchQuery || DEFAULT_WEATHER.location\n      };\n    }\n    \n    throw new Error(error instanceof Error ? error.message : 'Error fetching weather data');\n  }\n};\n\n// Get forecast for location\nexport const fetchForecast = async (\n  lat: number, \n  lon: number,\n  searchQuery?: string\n): Promise<ForecastDay[]> => {\n  try {\n    let latitude = lat;\n    let longitude = lon;\n\n    // If search query is provided, geocode it to get coordinates\n    if (searchQuery) {\n      try {\n        const geoResponse = await axios.get(buildApiUrl(`${GEO_URL}/direct`), {\n          params: {\n            q: searchQuery,\n            limit: 1,\n            appid: API_KEY\n          },\n          headers: {\n            'X-Requested-With': 'XMLHttpRequest'\n          }\n        });\n\n        if (geoResponse.data.length === 0) {\n          throw new Error(`Location \"${searchQuery}\" not found`);\n        }\n\n        const location = geoResponse.data[0];\n        latitude = location.lat;\n        longitude = location.lon;\n      } catch (geoError) {\n        console.error('Geocoding error:', geoError);\n        if (process.env.NODE_ENV === 'development') {\n          return generateMockForecast();\n        }\n        throw new Error(`Could not find location: ${searchQuery}`);\n      }\n    }\n\n    // Get 5-day forecast data\n    const forecastResponse = await axios.get(buildApiUrl(`${BASE_URL}/forecast`), {\n      params: {\n        lat: latitude,\n        lon: longitude,\n        units: 'metric',\n        appid: API_KEY\n      },\n      headers: {\n        'X-Requested-With': 'XMLHttpRequest'\n      }\n    });\n\n    const forecast: ForecastDay[] = [];\n    const dailyData: { [key: string]: any } = {};\n    \n    // Process forecast data (comes in 3-hour increments)\n    forecastResponse.data.list.forEach((item: any) => {\n      const date = new Date(item.dt * 1000);\n      const day = date.toISOString().split('T')[0];\n      \n      // Initialize daily data if it doesn't exist\n      if (!dailyData[day]) {\n        dailyData[day] = {\n          date: new Date(date),\n          minTemp: item.main.temp_min,\n          maxTemp: item.main.temp_max,\n          descriptions: {},\n          icons: {},\n          humidity: [],\n          windSpeed: [],\n          precipitation: item.pop * 100 || 0\n        };\n      } else {\n        // Update min/max temperatures\n        dailyData[day].minTemp = Math.min(dailyData[day].minTemp, item.main.temp_min);\n        dailyData[day].maxTemp = Math.max(dailyData[day].maxTemp, item.main.temp_max);\n        dailyData[day].precipitation = Math.max(dailyData[day].precipitation, item.pop * 100 || 0);\n      }\n      \n      // Track weather descriptions and icons to find most common\n      const desc = item.weather[0].description;\n      const icon = item.weather[0].icon.replace('n', 'd'); // normalize night/day icons\n      \n      dailyData[day].descriptions[desc] = (dailyData[day].descriptions[desc] || 0) + 1;\n      dailyData[day].icons[icon] = (dailyData[day].icons[icon] || 0) + 1;\n      \n      // Collect humidity and wind speed values\n      dailyData[day].humidity.push(item.main.humidity);\n      dailyData[day].windSpeed.push(item.wind.speed);\n    });\n    \n    // Convert daily data to forecast format\n    Object.keys(dailyData).forEach(day => {\n      const data = dailyData[day];\n      \n      // Find most common description and icon\n      let maxDescCount = 0;\n      let description = '';\n      Object.entries(data.descriptions).forEach(([desc, count]: [string, any]) => {\n        if (count > maxDescCount) {\n          maxDescCount = count;\n          description = desc;\n        }\n      });\n      \n      let maxIconCount = 0;\n      let icon = '';\n      Object.entries(data.icons).forEach(([ic, count]: [string, any]) => {\n        if (count > maxIconCount) {\n          maxIconCount = count;\n          icon = ic;\n        }\n      });\n      \n      // Calculate averages\n      const avgHumidity = Math.round(data.humidity.reduce((a: number, b: number) => a + b, 0) / data.humidity.length);\n      const avgWindSpeed = Math.round((data.windSpeed.reduce((a: number, b: number) => a + b, 0) / data.windSpeed.length) * 10) / 10;\n      \n      forecast.push({\n        date: data.date,\n        minTemp: data.minTemp,\n        maxTemp: data.maxTemp,\n        description,\n        icon,\n        precipitation: Math.round(data.precipitation),\n        humidity: avgHumidity,\n        windSpeed: avgWindSpeed\n      });\n    });\n    \n    // Sort by date\n    forecast.sort((a, b) => a.date.getTime() - b.date.getTime());\n    \n    // Limit to 5 days\n    return forecast.slice(0, 5);\n  } catch (error) {\n    console.error('Error fetching forecast data:', error);\n    \n    // In development mode, return mocked data if API fails\n    if (process.env.NODE_ENV === 'development') {\n      console.log('Using fallback forecast data in development mode');\n      return generateMockForecast();\n    }\n    \n    throw new Error(error instanceof Error ? error.message : 'Error fetching forecast data');\n  }\n};\n\n// Search for city autocomplete suggestions\nexport const searchCities = async (query: string): Promise<any[]> => {\n  if (!query || query.length < 2) return [];\n  \n  try {\n    const response = await axios.get(buildApiUrl(`${GEO_URL}/direct`), {\n      params: {\n        q: query,\n        limit: 5,\n        appid: API_KEY\n      },\n      headers: {\n        'X-Requested-With': 'XMLHttpRequest'\n      }\n    });\n    \n    return response.data.map((city: any) => ({\n      name: city.name,\n      state: city.state,\n      country: city.country,\n      lat: city.lat,\n      lon: city.lon,\n      displayName: `${city.name}${city.state ? `, ${city.state}` : ''}${city.country ? `, ${city.country}` : ''}`\n    }));\n  } catch (error) {\n    console.error('Error searching cities:', error);\n    return [];\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}