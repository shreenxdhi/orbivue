{"ast":null,"code":"import axios from 'axios';\n// API configuration\n// You should create an .env file and move this API key there in a real application\nconst API_KEY = 'f0fd7a09787e01aa6a78edace652c5d7'; // Free OpenWeatherMap API key for demo purposes\nconst BASE_URL = 'https://api.openweathermap.org/data/2.5';\nconst GEO_URL = 'https://api.openweathermap.org/geo/1.0';\n\n// Convert wind direction in degrees to cardinal direction\nconst getWindDirection = degrees => {\n  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];\n  return directions[Math.round(degrees / 45) % 8];\n};\n\n// Get weather data for location\nexport const fetchWeatherData = async (lat, lon, searchQuery) => {\n  try {\n    let latitude = lat;\n    let longitude = lon;\n    let locationName = '';\n\n    // If search query is provided, geocode it to get coordinates\n    if (searchQuery) {\n      const geoResponse = await axios.get(`${GEO_URL}/direct`, {\n        params: {\n          q: searchQuery,\n          limit: 1,\n          appid: API_KEY\n        }\n      });\n      if (geoResponse.data.length === 0) {\n        throw new Error(`Location \"${searchQuery}\" not found`);\n      }\n      const location = geoResponse.data[0];\n      latitude = location.lat;\n      longitude = location.lon;\n      locationName = location.name + (location.state ? `, ${location.state}` : '') + (location.country ? `, ${location.country}` : '');\n    }\n\n    // Get current weather data\n    const weatherResponse = await axios.get(`${BASE_URL}/weather`, {\n      params: {\n        lat: latitude,\n        lon: longitude,\n        units: 'metric',\n        appid: API_KEY\n      }\n    });\n    const data = weatherResponse.data;\n    return {\n      location: locationName || data.name,\n      temperature: data.main.temp,\n      feelsLike: data.main.feels_like,\n      humidity: data.main.humidity,\n      pressure: data.main.pressure,\n      windSpeed: data.wind.speed,\n      windDirection: getWindDirection(data.wind.deg),\n      description: data.weather[0].description,\n      icon: data.weather[0].icon,\n      sunrise: new Date(data.sys.sunrise * 1000),\n      sunset: new Date(data.sys.sunset * 1000)\n    };\n  } catch (error) {\n    console.error('Error fetching weather data:', error);\n    throw new Error('Error fetching weather data');\n  }\n};\n\n// Get forecast for location\nexport const fetchForecast = async (lat, lon, searchQuery) => {\n  try {\n    let latitude = lat;\n    let longitude = lon;\n\n    // If search query is provided, geocode it to get coordinates\n    if (searchQuery) {\n      const geoResponse = await axios.get(`${GEO_URL}/direct`, {\n        params: {\n          q: searchQuery,\n          limit: 1,\n          appid: API_KEY\n        }\n      });\n      if (geoResponse.data.length === 0) {\n        throw new Error(`Location \"${searchQuery}\" not found`);\n      }\n      const location = geoResponse.data[0];\n      latitude = location.lat;\n      longitude = location.lon;\n    }\n\n    // Get 5-day forecast data\n    const forecastResponse = await axios.get(`${BASE_URL}/forecast`, {\n      params: {\n        lat: latitude,\n        lon: longitude,\n        units: 'metric',\n        appid: API_KEY\n      }\n    });\n    const forecast = [];\n    const dailyData = {};\n\n    // Process forecast data (comes in 3-hour increments)\n    forecastResponse.data.list.forEach(item => {\n      const date = new Date(item.dt * 1000);\n      const day = date.toISOString().split('T')[0];\n\n      // Initialize daily data if it doesn't exist\n      if (!dailyData[day]) {\n        dailyData[day] = {\n          date: new Date(date),\n          minTemp: item.main.temp_min,\n          maxTemp: item.main.temp_max,\n          descriptions: {},\n          icons: {},\n          humidity: [],\n          windSpeed: [],\n          precipitation: item.pop * 100 || 0\n        };\n      } else {\n        // Update min/max temperatures\n        dailyData[day].minTemp = Math.min(dailyData[day].minTemp, item.main.temp_min);\n        dailyData[day].maxTemp = Math.max(dailyData[day].maxTemp, item.main.temp_max);\n        dailyData[day].precipitation = Math.max(dailyData[day].precipitation, item.pop * 100 || 0);\n      }\n\n      // Track weather descriptions and icons to find most common\n      const desc = item.weather[0].description;\n      const icon = item.weather[0].icon.replace('n', 'd'); // normalize night/day icons\n\n      dailyData[day].descriptions[desc] = (dailyData[day].descriptions[desc] || 0) + 1;\n      dailyData[day].icons[icon] = (dailyData[day].icons[icon] || 0) + 1;\n\n      // Collect humidity and wind speed values\n      dailyData[day].humidity.push(item.main.humidity);\n      dailyData[day].windSpeed.push(item.wind.speed);\n    });\n\n    // Convert daily data to forecast format\n    Object.keys(dailyData).forEach(day => {\n      const data = dailyData[day];\n\n      // Find most common description and icon\n      let maxDescCount = 0;\n      let description = '';\n      Object.entries(data.descriptions).forEach(([desc, count]) => {\n        if (count > maxDescCount) {\n          maxDescCount = count;\n          description = desc;\n        }\n      });\n      let maxIconCount = 0;\n      let icon = '';\n      Object.entries(data.icons).forEach(([ic, count]) => {\n        if (count > maxIconCount) {\n          maxIconCount = count;\n          icon = ic;\n        }\n      });\n\n      // Calculate averages\n      const avgHumidity = Math.round(data.humidity.reduce((a, b) => a + b, 0) / data.humidity.length);\n      const avgWindSpeed = Math.round(data.windSpeed.reduce((a, b) => a + b, 0) / data.windSpeed.length * 10) / 10;\n      forecast.push({\n        date: data.date,\n        minTemp: data.minTemp,\n        maxTemp: data.maxTemp,\n        description,\n        icon,\n        precipitation: Math.round(data.precipitation),\n        humidity: avgHumidity,\n        windSpeed: avgWindSpeed\n      });\n    });\n\n    // Sort by date\n    forecast.sort((a, b) => a.date.getTime() - b.date.getTime());\n\n    // Limit to 5 days\n    return forecast.slice(0, 5);\n  } catch (error) {\n    console.error('Error fetching forecast data:', error);\n    throw new Error('Error fetching forecast data');\n  }\n};\n\n// Search for city autocomplete suggestions\nexport const searchCities = async query => {\n  if (!query || query.length < 2) return [];\n  try {\n    const response = await axios.get(`${GEO_URL}/direct`, {\n      params: {\n        q: query,\n        limit: 5,\n        appid: API_KEY\n      }\n    });\n    return response.data.map(city => ({\n      name: city.name,\n      state: city.state,\n      country: city.country,\n      lat: city.lat,\n      lon: city.lon,\n      displayName: `${city.name}${city.state ? `, ${city.state}` : ''}${city.country ? `, ${city.country}` : ''}`\n    }));\n  } catch (error) {\n    console.error('Error searching cities:', error);\n    return [];\n  }\n};","map":{"version":3,"names":["axios","API_KEY","BASE_URL","GEO_URL","getWindDirection","degrees","directions","Math","round","fetchWeatherData","lat","lon","searchQuery","latitude","longitude","locationName","geoResponse","get","params","q","limit","appid","data","length","Error","location","name","state","country","weatherResponse","units","temperature","main","temp","feelsLike","feels_like","humidity","pressure","windSpeed","wind","speed","windDirection","deg","description","weather","icon","sunrise","Date","sys","sunset","error","console","fetchForecast","forecastResponse","forecast","dailyData","list","forEach","item","date","dt","day","toISOString","split","minTemp","temp_min","maxTemp","temp_max","descriptions","icons","precipitation","pop","min","max","desc","replace","push","Object","keys","maxDescCount","entries","count","maxIconCount","ic","avgHumidity","reduce","a","b","avgWindSpeed","sort","getTime","slice","searchCities","query","response","map","city","displayName"],"sources":["/Users/shreenidhivasishta/sat/orbivue/src/services/weatherService.ts"],"sourcesContent":["import axios from 'axios';\n\ninterface WeatherData {\n  location: string;\n  temperature: number;\n  feelsLike: number;\n  humidity: number;\n  pressure: number;\n  windSpeed: number;\n  windDirection: string;\n  description: string;\n  icon: string;\n  sunrise: Date;\n  sunset: Date;\n}\n\ninterface ForecastDay {\n  date: Date;\n  minTemp: number;\n  maxTemp: number;\n  description: string;\n  icon: string;\n  precipitation: number;\n  humidity: number;\n  windSpeed: number;\n}\n\n// API configuration\n// You should create an .env file and move this API key there in a real application\nconst API_KEY = 'f0fd7a09787e01aa6a78edace652c5d7'; // Free OpenWeatherMap API key for demo purposes\nconst BASE_URL = 'https://api.openweathermap.org/data/2.5';\nconst GEO_URL = 'https://api.openweathermap.org/geo/1.0';\n\n// Convert wind direction in degrees to cardinal direction\nconst getWindDirection = (degrees: number): string => {\n  const directions = ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'];\n  return directions[Math.round(degrees / 45) % 8];\n};\n\n// Get weather data for location\nexport const fetchWeatherData = async (\n  lat: number, \n  lon: number, \n  searchQuery?: string\n): Promise<WeatherData> => {\n  try {\n    let latitude = lat;\n    let longitude = lon;\n    let locationName = '';\n\n    // If search query is provided, geocode it to get coordinates\n    if (searchQuery) {\n      const geoResponse = await axios.get(`${GEO_URL}/direct`, {\n        params: {\n          q: searchQuery,\n          limit: 1,\n          appid: API_KEY\n        }\n      });\n\n      if (geoResponse.data.length === 0) {\n        throw new Error(`Location \"${searchQuery}\" not found`);\n      }\n\n      const location = geoResponse.data[0];\n      latitude = location.lat;\n      longitude = location.lon;\n      locationName = location.name + (location.state ? `, ${location.state}` : '') + (location.country ? `, ${location.country}` : '');\n    }\n\n    // Get current weather data\n    const weatherResponse = await axios.get(`${BASE_URL}/weather`, {\n      params: {\n        lat: latitude,\n        lon: longitude,\n        units: 'metric',\n        appid: API_KEY\n      }\n    });\n\n    const data = weatherResponse.data;\n    \n    return {\n      location: locationName || data.name,\n      temperature: data.main.temp,\n      feelsLike: data.main.feels_like,\n      humidity: data.main.humidity,\n      pressure: data.main.pressure,\n      windSpeed: data.wind.speed,\n      windDirection: getWindDirection(data.wind.deg),\n      description: data.weather[0].description,\n      icon: data.weather[0].icon,\n      sunrise: new Date(data.sys.sunrise * 1000),\n      sunset: new Date(data.sys.sunset * 1000),\n    };\n  } catch (error) {\n    console.error('Error fetching weather data:', error);\n    throw new Error('Error fetching weather data');\n  }\n};\n\n// Get forecast for location\nexport const fetchForecast = async (\n  lat: number, \n  lon: number,\n  searchQuery?: string\n): Promise<ForecastDay[]> => {\n  try {\n    let latitude = lat;\n    let longitude = lon;\n\n    // If search query is provided, geocode it to get coordinates\n    if (searchQuery) {\n      const geoResponse = await axios.get(`${GEO_URL}/direct`, {\n        params: {\n          q: searchQuery,\n          limit: 1,\n          appid: API_KEY\n        }\n      });\n\n      if (geoResponse.data.length === 0) {\n        throw new Error(`Location \"${searchQuery}\" not found`);\n      }\n\n      const location = geoResponse.data[0];\n      latitude = location.lat;\n      longitude = location.lon;\n    }\n\n    // Get 5-day forecast data\n    const forecastResponse = await axios.get(`${BASE_URL}/forecast`, {\n      params: {\n        lat: latitude,\n        lon: longitude,\n        units: 'metric',\n        appid: API_KEY\n      }\n    });\n\n    const forecast: ForecastDay[] = [];\n    const dailyData: { [key: string]: any } = {};\n    \n    // Process forecast data (comes in 3-hour increments)\n    forecastResponse.data.list.forEach((item: any) => {\n      const date = new Date(item.dt * 1000);\n      const day = date.toISOString().split('T')[0];\n      \n      // Initialize daily data if it doesn't exist\n      if (!dailyData[day]) {\n        dailyData[day] = {\n          date: new Date(date),\n          minTemp: item.main.temp_min,\n          maxTemp: item.main.temp_max,\n          descriptions: {},\n          icons: {},\n          humidity: [],\n          windSpeed: [],\n          precipitation: item.pop * 100 || 0\n        };\n      } else {\n        // Update min/max temperatures\n        dailyData[day].minTemp = Math.min(dailyData[day].minTemp, item.main.temp_min);\n        dailyData[day].maxTemp = Math.max(dailyData[day].maxTemp, item.main.temp_max);\n        dailyData[day].precipitation = Math.max(dailyData[day].precipitation, item.pop * 100 || 0);\n      }\n      \n      // Track weather descriptions and icons to find most common\n      const desc = item.weather[0].description;\n      const icon = item.weather[0].icon.replace('n', 'd'); // normalize night/day icons\n      \n      dailyData[day].descriptions[desc] = (dailyData[day].descriptions[desc] || 0) + 1;\n      dailyData[day].icons[icon] = (dailyData[day].icons[icon] || 0) + 1;\n      \n      // Collect humidity and wind speed values\n      dailyData[day].humidity.push(item.main.humidity);\n      dailyData[day].windSpeed.push(item.wind.speed);\n    });\n    \n    // Convert daily data to forecast format\n    Object.keys(dailyData).forEach(day => {\n      const data = dailyData[day];\n      \n      // Find most common description and icon\n      let maxDescCount = 0;\n      let description = '';\n      Object.entries(data.descriptions).forEach(([desc, count]: [string, any]) => {\n        if (count > maxDescCount) {\n          maxDescCount = count;\n          description = desc;\n        }\n      });\n      \n      let maxIconCount = 0;\n      let icon = '';\n      Object.entries(data.icons).forEach(([ic, count]: [string, any]) => {\n        if (count > maxIconCount) {\n          maxIconCount = count;\n          icon = ic;\n        }\n      });\n      \n      // Calculate averages\n      const avgHumidity = Math.round(data.humidity.reduce((a: number, b: number) => a + b, 0) / data.humidity.length);\n      const avgWindSpeed = Math.round((data.windSpeed.reduce((a: number, b: number) => a + b, 0) / data.windSpeed.length) * 10) / 10;\n      \n      forecast.push({\n        date: data.date,\n        minTemp: data.minTemp,\n        maxTemp: data.maxTemp,\n        description,\n        icon,\n        precipitation: Math.round(data.precipitation),\n        humidity: avgHumidity,\n        windSpeed: avgWindSpeed\n      });\n    });\n    \n    // Sort by date\n    forecast.sort((a, b) => a.date.getTime() - b.date.getTime());\n    \n    // Limit to 5 days\n    return forecast.slice(0, 5);\n  } catch (error) {\n    console.error('Error fetching forecast data:', error);\n    throw new Error('Error fetching forecast data');\n  }\n};\n\n// Search for city autocomplete suggestions\nexport const searchCities = async (query: string): Promise<any[]> => {\n  if (!query || query.length < 2) return [];\n  \n  try {\n    const response = await axios.get(`${GEO_URL}/direct`, {\n      params: {\n        q: query,\n        limit: 5,\n        appid: API_KEY\n      }\n    });\n    \n    return response.data.map((city: any) => ({\n      name: city.name,\n      state: city.state,\n      country: city.country,\n      lat: city.lat,\n      lon: city.lon,\n      displayName: `${city.name}${city.state ? `, ${city.state}` : ''}${city.country ? `, ${city.country}` : ''}`\n    }));\n  } catch (error) {\n    console.error('Error searching cities:', error);\n    return [];\n  }\n}; "],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}